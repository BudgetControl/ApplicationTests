#!/usr/bin/env php
<?php

/**
 * BudgetControl Seeds Runner
 * 
 * This executable allows running seeds from the command line using vendor/bin/bc-application
 * 
 * Usage:
 *   vendor/bin/bc-application [options]
 * 
 * Options:
 *   --path=<path>        Custom path to seeds directory (default: resources/seeds)
 *   --verbose            Enable verbose output
 *   --quiet              Disable all output
 *   --help               Show this help message
 *   --list               List all discovered seeds without executing them
 *   --seed=<name>        Run only a specific seed by name
 *   --seeds              Run all seeds in the specified path
 *   --drop-schema        Drop the database schema before running
 *   --migrate            Run Phinx migrations before seeds
 *   --rollback           Rollback migrations to target (use with --target)
 *   --target=<target>    Target for rollback (version number or 0 for all)
 *   --environment=<env>  Phinx environment (default: development)
 *   --config=<path>      Path to phinx configuration file (default: phinx.php)
 * 
 * @package Budgetcontrol\ApplicationTests
 * @author Marco De Felice <marco.defelice@mlabfactory.it>
 */

// Find the bootstrap or autoloader
$bootstrapPaths = [
    __DIR__ . '/../../bootstrap/app.php',          // BudgetControl bootstrap (preferred)
    getcwd() . '/bootstrap/app.php',               // Project root bootstrap
    __DIR__ . '/../../../bootstrap/app.php',       // Alternative bootstrap location
];

$autoloadPaths = [
    __DIR__ . '/../vendor/autoload.php',           // When developing the package
    __DIR__ . '/../../../autoload.php',           // When installed as dependency
    __DIR__ . '/../../../../autoload.php',        // Alternative vendor structure
    getcwd() . '/vendor/autoload.php',            // When run from project root
];

$app = null;
$bootstrapUsed = false;

// Try to load BudgetControl bootstrap first
foreach ($bootstrapPaths as $path) {
    if (file_exists($path)) {
        $app = require_once $path;
        $bootstrapUsed = true;
        break;
    }
}

// If no bootstrap found, try standard Composer autoloader
if (!$app) {
    foreach ($autoloadPaths as $path) {
        if (file_exists($path)) {
            $app = require_once $path;
            break;
        }
    }
}

if (!$app) {
    echo "Error: Could not find BudgetControl bootstrap or Composer autoloader.\n";
    echo "Please ensure you're running this from a BudgetControl project or run 'composer install'.\n";
    echo "\nSearched bootstrap paths:\n";
    foreach ($bootstrapPaths as $path) {
        echo "  - {$path}\n";
    }
    echo "\nSearched autoloader paths:\n";
    foreach ($autoloadPaths as $path) {
        echo "  - {$path}\n";
    }
    exit(1);
}

use Budgetcontrol\ApplicationTests\Seeds\RunSeeds;

/**
 * Parse command line arguments
 */
function parseArguments(array $argv): array
{
    $options = [
        'verbose' => false,
        'quiet' => false,
        'help' => false,
        'list' => false,
        'path' => null,
        'seed' => null,
        'drop-schema' => false,
        'migrate' => false,
        'rollback' => false,
        'target' => null,
        'environment' => 'development',
        'config' => 'phinx.php',
        'seeds' => false,
    ];

    for ($i = 1; $i < count($argv); $i++) {
        $arg = $argv[$i];

        if ($arg === '--verbose' || $arg === '-v') {
            $options['verbose'] = true;
        } elseif ($arg === '--quiet' || $arg === '-q') {
            $options['quiet'] = true;
        } elseif ($arg === '--help' || $arg === '-h') {
            $options['help'] = true;
        } elseif ($arg === '--list' || $arg === '-l') {
            $options['list'] = true;
        } elseif ($arg === '--drop-schema') {
            $options['drop-schema'] = true;
        } elseif ($arg === '--migrate') {
            $options['migrate'] = true;
        } elseif ($arg === '--rollback') {
            $options['rollback'] = true;
        } elseif (strpos($arg, '--path=') === 0) {
            $options['path'] = substr($arg, 7);
        } elseif (strpos($arg, '--seed=') === 0) {
            $options['seed'] = substr($arg, 7);
        } elseif (strpos($arg, '--target=') === 0) {
            $options['target'] = substr($arg, 9);
        } elseif (strpos($arg, '--environment=') === 0) {
            $options['environment'] = substr($arg, 14);
        } elseif (strpos($arg, '--config=') === 0) {
            $options['config'] = substr($arg, 9);
        } elseif ($arg === '--seeds') {
            $options['seeds'] = true;
        } else {
            echo "Warning: Unknown option '{$arg}'\n";
        }
    }

    return $options;
}

/**
 * Show help message
 */
function showHelp(): void
{
    echo "\n";
    echo "BudgetControl Application Runner\n";
    echo "===============================\n\n";
    echo "Usage:\n";
    echo "  vendor/bin/bc-application [options]\n\n";
    echo "Options:\n";
    echo "  --path=<path>        Custom path to seeds directory (default: resources/seeds)\n";
    echo "  --verbose, -v        Enable verbose output\n";
    echo "  --quiet, -q          Disable all output\n";
    echo "  --help, -h           Show this help message\n";
    echo "  --list, -l           List all discovered seeds without executing them\n";
    echo "  --seed=<name>        Run only a specific seed by name\n";
    echo "  --seeds              Run all seeds in the specified path\n";
    echo "  --drop-schema        Drop the database schema before running\n";
    echo "  --migrate            Run Phinx migrations before seeds\n";
    echo "  --rollback           Rollback migrations to target\n";
    echo "  --target=<target>    Target for rollback (version number or 0 for all)\n";
    echo "  --environment=<env>  Phinx environment (default: development)\n";
    echo "  --config=<path>      Path to phinx configuration file (default: phinx.php)\n\n";
    echo "Examples:\n";
    echo "  vendor/bin/bc-application --verbose\n";
    echo "  vendor/bin/bc-application --drop-schema --migrate\n";
    echo "  vendor/bin/bc-application --rollback --target=0\n";
    echo "  vendor/bin/bc-application --environment=testing --migrate\n";
    echo "  vendor/bin/bc-application --path=database/seeds --seed=UserSeed\n\n";
    echo "Common workflows:\n";
    echo "  # Fresh database with migrations and seeds\n";
    echo "  vendor/bin/bc-application --drop-schema --migrate\n\n";
    echo "  # Reset database completely\n";
    echo "  vendor/bin/bc-application --rollback --target=0 --drop-schema\n\n";
}

/**
 * Drop database schema
 */
function dropSchema(string $environment, string $configPath, callable $logger): bool
{
    $logger("Dropping database schema...", 'info');

    if (!file_exists($configPath)) {
        $logger("Phinx config file not found: {$configPath}", 'error');
        return false;
    }

    $config = require $configPath;

    if (!isset($config['environments'][$environment])) {
        $logger("Environment '{$environment}' not found in config", 'error');
        return false;
    }

    $dbConfig = $config['environments'][$environment];

    try {
        // Per PostgreSQL dobbiamo connetterci al database di sistema 'postgres'
        if ($dbConfig['adapter'] === 'pgsql') {
            $dsn = sprintf(
                "pgsql:host=%s;port=%s;dbname=postgres",
                $dbConfig['host'],
                $dbConfig['port'] ?? 5432
            );
        } else {
            // MySQL/MariaDB
            $dsn = sprintf(
                "%s:host=%s;port=%s",
                $dbConfig['adapter'],
                $dbConfig['host'],
                $dbConfig['port'] ?? 3306
            );
        }

        $pdo = new PDO($dsn, $dbConfig['user'], $dbConfig['pass']);
        $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

        $dbName = $dbConfig['name'];

        if ($dbConfig['adapter'] === 'pgsql') {
            // PostgreSQL - termina connessioni attive prima di droppare
            $pdo->exec("SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '{$dbName}' AND pid <> pg_backend_pid()");
            $pdo->exec("DROP DATABASE IF EXISTS \"{$dbName}\"");
            $logger("Database '{$dbName}' dropped successfully", 'info');

            // Crea database
            $pdo->exec("CREATE DATABASE \"{$dbName}\" WITH ENCODING 'UTF8'");
            $logger("Database '{$dbName}' created successfully", 'info');
        } else {
            // MySQL/MariaDB
            $pdo->exec("DROP DATABASE IF EXISTS `{$dbName}`");
            $logger("Database '{$dbName}' dropped successfully", 'info');

            $pdo->exec("CREATE DATABASE `{$dbName}` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci");
            $logger("Database '{$dbName}' created successfully", 'info');
        }

        return true;
    } catch (PDOException $e) {
        $logger("Failed to drop schema: " . $e->getMessage(), 'error');
        return false;
    }
}

/**
 * Run Phinx migrations
 */
function runMigrations(string $environment, string $configPath, callable $logger, bool $verbose = false): bool
{
    $logger("Running Phinx migrations...", 'info');

    if (!file_exists($configPath)) {
        $logger("Phinx config file not found: {$configPath}", 'error');
        return false;
    }

    $phinxBinary = findPhinxBinary();
    if (!$phinxBinary) {
        $logger("Phinx binary not found", 'error');
        return false;
    }

    $verboseFlag = $verbose ? ' -v' : '';
    $command = "{$phinxBinary} migrate -c {$configPath} -e {$environment}{$verboseFlag}";

    $logger("Executing: {$command}", 'info');

    $output = [];
    $returnCode = 0;
    exec($command . ' 2>&1', $output, $returnCode);

    if ($returnCode === 0) {
        $logger("Migrations completed successfully", 'info');
        if ($verbose) {
            foreach ($output as $line) {
                echo "  {$line}\n";
            }
        }
        return true;
    } else {
        $logger("Migrations failed with return code: {$returnCode}", 'error');
        foreach ($output as $line) {
            $logger("  {$line}", 'error');
        }
        return false;
    }
}

/**
 * Rollback Phinx migrations
 */
function rollbackMigrations(string $environment, string $configPath, ?string $target, callable $logger, bool $verbose = false): bool
{
    $logger("Rolling back Phinx migrations...", 'info');

    if (!file_exists($configPath)) {
        $logger("Phinx config file not found: {$configPath}", 'error');
        return false;
    }

    $phinxBinary = findPhinxBinary();
    if (!$phinxBinary) {
        $logger("Phinx binary not found", 'error');
        return false;
    }

    $targetFlag = $target !== null ? " -t {$target}" : '';
    $verboseFlag = $verbose ? ' -v' : '';
    $command = "{$phinxBinary} rollback -c {$configPath} -e {$environment}{$targetFlag}{$verboseFlag}";

    $logger("Executing: {$command}", 'info');

    $output = [];
    $returnCode = 0;
    exec($command . ' 2>&1', $output, $returnCode);

    if ($returnCode === 0) {
        $logger("Rollback completed successfully", 'info');
        if ($verbose) {
            foreach ($output as $line) {
                echo "  {$line}\n";
            }
        }
        return true;
    } else {
        $logger("Rollback failed with return code: {$returnCode}", 'error');
        foreach ($output as $line) {
            $logger("  {$line}", 'error');
        }
        return false;
    }
}

/**
 * Find Phinx binary
 */
function findPhinxBinary(): ?string
{
    $phinxPaths = [
        __DIR__ . '/../../../bin/phinx',           // When installed as dependency
        __DIR__ . '/../vendor/bin/phinx',          // When developing the package
        getcwd() . '/vendor/bin/phinx',            // When run from project root
        'phinx',                                   // Global installation
    ];

    foreach ($phinxPaths as $path) {
        if (file_exists($path) && is_executable($path)) {
            return $path;
        }
    }

    // Try with which command
    $which = shell_exec('which phinx 2>/dev/null');
    if ($which && file_exists(trim($which))) {
        return trim($which);
    }

    return null;
}

/**
 * Custom logger for the CLI
 */
function createCliLogger(bool $quiet): callable
{
    return function (string $message, string $level = 'info') use ($quiet) {
        if ($quiet) {
            return;
        }

        $colors = [
            'info' => "\033[0;32m",    // Green
            'error' => "\033[0;31m",   // Red
            'warning' => "\033[0;33m", // Yellow
        ];

        $reset = "\033[0m";
        $color = $colors[$level] ?? $colors['info'];

        $timestamp = date('Y-m-d H:i:s');
        $levelUpper = strtoupper($level);

        echo "{$color}[{$timestamp}] [{$levelUpper}]{$reset} {$message}\n";
    };
}

// Main execution
try {
    $options = parseArguments($argv);

    if ($options['help']) {
        showHelp();
        exit(0);
    }

    // Create logger
    $logger = createCliLogger($options['quiet']);
    $verbose = $options['verbose'] && !$options['quiet'];

    // Validate config file if database operations are requested
    if ($options['drop-schema'] || $options['migrate'] || $options['rollback']) {
        if (!file_exists($options['config'])) {
            $logger("Phinx config file not found: {$options['config']}", 'error');
            $logger("Use --config=<path> to specify a different config file", 'info');
            exit(1);
        }
    }

    // Drop schema if requested
    if ($options['drop-schema']) {
        if (!dropSchema($options['environment'], $options['config'], $logger)) {
            $logger("Failed to drop schema", 'error');
            exit(1);
        }
    }

    // Rollback migrations if requested
    if ($options['rollback']) {
        if (!rollbackMigrations($options['environment'], $options['config'], $options['target'], $logger, $verbose)) {
            $logger("Failed to rollback migrations", 'error');
            exit(1);
        }
    }

    // Run migrations if requested
    if ($options['migrate']) {
        if (!runMigrations($options['environment'], $options['config'], $logger, $verbose)) {
            $logger("Failed to run migrations", 'error');
            exit(1);
        }
    }

    // Create seeds runner
    $runner = new RunSeeds($verbose, $logger);

    // Discover seeds
    $seedsPath = $options['path'];

    if ($seedsPath) {
        if (!is_dir($seedsPath)) {
            $logger("Error: Seeds directory does not exist: {$seedsPath}", 'error');
            exit(1);
        }
        $runner->discoverSeeds($seedsPath);
    } else {
        if ($options['migrate'] || $options['seeds']) {
            // Use the private method through reflection to get user seeds path
            $reflection = new ReflectionClass($runner);
            $method = $reflection->getMethod('getUserSeedsPath');
            $method->setAccessible(true);
            $seedsPath = $method->invoke($runner);

            if (is_dir($seedsPath)) {
                $runner->discoverSeeds($seedsPath);
            } else {
                $logger("Seeds directory not found: {$seedsPath}", 'warning');
                $logger("Creating seeds directory...", 'info');
                mkdir($seedsPath, 0755, true);
                $logger("Seeds directory created: {$seedsPath}", 'info');
            }
        }
    }

    // List seeds if requested
    if ($options['list']) {
        $seeds = $runner->getRegisteredSeeds();

        if (empty($seeds)) {
            $logger("No seeds found in {$seedsPath}", 'warning');
        } else {
            $logger("Discovered seeds:", 'info');
            foreach ($seeds as $seedName) {
                $seed = $runner->getSeed($seedName);
                echo "  - {$seedName}: " . $seed->getDescription() . "\n";
            }
        }
        exit(0);
    }

    // Run specific seed or all seeds
    if ($options['seed']) {
        $runner->runSeed($options['seed']);
        $logger("Seed '{$options['seed']}' completed successfully!", 'info');
    } else {
        $seeds = $runner->getRegisteredSeeds();

        if (empty($seeds)) {
            $logger("No seeds to execute in {$seedsPath}", 'warning');
        } else {
            $runner->run();
            $logger("All seeds completed successfully!", 'info');
        }
    }

    exit(0);
} catch (Exception $e) {
    $logger = $logger ?? function ($msg, $level) {
        echo "[ERROR] {$msg}\n";
    };
    $logger("Fatal error: " . $e->getMessage(), 'error');

    if (isset($options) && $options['verbose']) {
        $logger("Stack trace:", 'error');
        echo $e->getTraceAsString() . "\n";
    }

    exit(1);
} catch (Error $e) {
    $logger = $logger ?? function ($msg, $level) {
        echo "[ERROR] {$msg}\n";
    };
    $logger("Fatal error: " . $e->getMessage(), 'error');

    if (isset($options) && $options['verbose']) {
        $logger("Stack trace:", 'error');
        echo $e->getTraceAsString() . "\n";
    }

    exit(1);
}